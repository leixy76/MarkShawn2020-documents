>本文纯技术，适合对象：中高级前端工程师。

在之前的文章（[还在用截图 Vibe Coding？太慢了！](https://mp.weixin.qq.com/s/Sjr_7YQgtZzNM5v28oZ9mA)）中，我们给出了一款前端插件 [code-inspector-plugin - npm](https://www.npmjs.com/package/code-inspector-plugin)，它是我在Dify源码中挖出来的得力工具，允许我们自动在IDE中打开前端组件所在的源代码位置。

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7a682d6c782f7374617469632d696d672f636f64652d696e73706563746f722f64656d6f2e676966.gif)


目前流量也不错，稳步增长。

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105172439940.png)

但由于我是重度vibe cli coder，更加喜欢在claude code、codex中优化代码，所以不太需要跳转IDE打开的功能，但为了提高上下文的准确性，有很多复制具体路径的需求（其实进一步分析的话，也可以是跳转IDE打开，只不过这个IDE可能是我们的iTerm（是不是一个极好的需求：））。

因此，我当时就花了一些时间魔改了代码，实现了这样的功能，以加速我们的vibe coding开发效率。

不过当时有两个问题悬而未解。

一个问题是：不理解为什么 pnpm add local file 的方式不奏效，导致开发效率较慢（虽然可以 pnpm link，但还是不如pnpm add 不同的源比较方便）。

另一个问题是：我们为了能在不被merge的基础上，让其他项目以及让其他人方便集成，选择了更换package scope name在npmjs独立发包，从而导致了代码的大幅改动、与upstream脱轨，可维护性变差（我们暂时只是想增加一个feature，而非想独立做一份分发版本）。

最近我联系上了原作者，和他交流该feature的设计，不过还没有达成共识。

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105174112464.png)


并且原作目前的重心暂时不在这，所以只能我自己动手了：）

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105174027321.png)

最终，我花了大概整整两天的时间，分析与debug了原作的一整套代码，完美解决了上述两个问题。

关于第一个问题，其实是源代码（packages/core/src/server/use-client.ts:382）中设计的包索引机制不够robust，导致不支持被外部的代码引用，出现Module Not Found的问题。

cc 将待生成目标文件的存储位置修改成被执行环境的 .cache 文件夹，这样支持了本地demo和pnpm外部引用两种开发环境，完美解决。

关于第二个问题，我向AI讨教了很久，最终得出的结论是可以通过 cloudsmith 实现私有包发布而规避了修改包名的问题。

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105174745821.png)

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105174729247.png)

不过在使用上，稍微复杂了一点点，需要我们首先在 `.npmrc` （没有的话就新建）内填写：

```yaml

```

但还是不够优雅，有没有办法不用手动指定 `pnpm add` 的 registry 呢？

但这个问题没有那么好解决，因为 `.npmrc` 里只支持自定义 scope packages （也就是 `@code-inspector/xxx`）的registry，对于非scope （也就是`code-inspector-plugin`）的packages是不支持的，它只支持直接修改所有packages的默认registry：

```yaml
registry=https://npm.cloudsmith.io/mark/code-inspector/
```

但这样会导致所有的包都通过我们的cloudsmith下载，可我们只托管了code-inspector相关的包，没有托管全部啊。

不慌，cc还告诉了我们一个解决办法，那就是设置 upstream。

打开 https://cloudsmith.io/~mark/repos/code-inspector/upstreams/ 设置 npmjs 的upstream，勾选认证即可。这样所有我们cloudsmith没有的包就会自动从npmjs拉取。

![](https://the-dummy.oss-cn-beijing.aliyuncs.com/undefined20251105175744733.png)

为了避免某些包的认证问题，我们还需要在`.npmrc`中额外补一句：

```
always-auth=true
```

这样，当我们执行 `pnpm add code-inspector-plugin` 时，它会优先从我们的cloudsmith中拉取我们发布的源代码，而非npmjs。

优雅～

当然，如果你不想在registry这一层做这么多中转，我们还是推荐使用指定registry的安装方式：

```
pnpm add code-inspector-plugin@https://npm.cloudsmith.io/mark/code-inspector/code-inspector-plugin/-/code-inspector-plugin-1.2.11.tgz 
```

由于它依赖很多分包，所以我们要指定分包的地址，在`.npmrc`中增加：

```
@code-inspector:registry=https://npm.cloudsmith.io/mark/code-inspector/
```

综上，有两种办法基于私有registry server，实现我们的优雅开发（无需被upstream merge，无需修改scope name）。

欢迎大家尝试使用，我也会和原作者就我们的研究做进一步探讨，有进展继续和大家同步～

在文尾，我希望大家再次回过头来，梳理为什么我们要花这么大精力，只为了得到一个前端组件的源代码地址。

答案只有一个。

那就是「精准的上下文工程」。

期待你的 vibe coding 顺利。