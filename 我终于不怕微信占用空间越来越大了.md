
一直以来，微信占用体积一直是很多用户电脑、手机上的重大难题，它往往占用巨大，而且越来越大。

根据我自己的实际经验，手机上的图库一年大概累积100G左右，而微信聊天数据也大概是这么个量，实际每个人可能略有差异。

而我的电脑磁盘其实并不大，区区512G，手机端则更小，只有256G，常常捉襟见肘。

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/a3c489a80b02820c17b826dd31ef7e2c.png?x-oss-process=image/quality,q_90/rotate,0)

微信的官方解决方案是使用备份手段，但说实话，备份的体验真地很差，因为是基于wifi加密传输的，而且还有奇怪的限制。

我能理解微信的良苦用心，但对于程序员来说实在难以忍受。

另外一个被吐槽已久的设计，是对于转发文件的重复存储，试想一下你有一个 1 G 的视频，结果在10个群里都转了一下，对不起，你的电脑将立即少掉10个G的存储空间，而且每个收到并点击播放的人都少了N个G的空间。

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/0aa36c219195c293580890d31c85f38b.png?x-oss-process=image/quality,q_90/rotate,0)

我查看自己的微信文件夹，确实如此，每个带`(数字)`的文件，都是一个重复文件：

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/5d741a9b4cf9d091cfe96d40e4408e00.png?x-oss-process=image/quality,q_90/rotate,0)

以前年轻不懂事，脾气也爆，当别人发给自己一个 `xxx.yy(N)`的文件时，我都会非常生气：*你就不能先重命名好文件再发给我？*

对方淡淡地回道：*有没有可能是微信自己加的后缀？*

多年以后，这段对话从遥远的记忆里赶来，正中眉心。

而今天，我想教大家一个非常简单粗暴的办法，让你彻底不用再担心自己的磁盘被撑爆，只要你有一块独立的外接固态磁盘。

*我自己买的是三星T7固态硬盘，颜值很高，造型小巧，买了两块，用了很久。*

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/d4fcd0b8b7951e013159145c31a0ddc5.png?x-oss-process=image/quality,q_90/rotate,0)

当我们接上去之后，我们只需要两步。

- 第一步：把微信整个数据文件夹全部移到外接磁盘，并在原位置软链接；
- 第二步（整整花了两天才研究明白）：（MacOS）对微信软件重新签名以越过沙箱检测问题。

原理很简单，我们通过软链接形式，让微信只在外接磁盘吃喝拉撒，微信自己对底层的文件系统是无感知的，所以不影响微信运行。

对于第一步，你可以使用我们手工川Vibe Coding 的自动移动并软链接命令：

```shell
# 函数：移动文件/目录并创建链接（正向），或恢复链接为原始文件/目录（反向）
# v2.0 - macOS 兼容版
#
# 用法 (正向): mvln <源文件/目录> <目标目录>
# 用法 (反向): mvln -r <符号链接>

function mvln() {
  # === 反向操作逻辑 (无需修改，已兼容) ===
  if [[ "$1" == "-r" || "$1" == "--reverse" ]]; then
    if [ "$#" -ne 2 ]; then echo "反向操作用法: mvln -r <符号链接>"; return 1; fi
    local link_path="$2"
    if [ ! -L "$link_path" ]; then echo "错误: '$link_path' 不是一个符号链接或不存在。"; return 1; fi
    local target_path=$(realpath "$link_path")
    if [ ! -e "$target_path" ]; then echo "错误: 链接指向的目标 '$target_path' 不存在。"; return 1; fi
    
    echo "准备执行反向操作..."
    echo "  - 目标: $target_path"
    echo "  - 将移回至: $link_path"
    
    rm "$link_path" && mv "$target_path" "$link_path" && echo "✅ 操作成功！"
    return 0
  fi

  # === 正向操作逻辑 (重写以兼容 macOS) ===
  if [ "$#" -ne 2 ]; then echo "正向操作用法: mvln <源文件/目录> <目标目录>"; return 1; fi

  local source_arg="$1"
  local dest_dir_arg="$2"

  # 错误检查
  if [ ! -e "$source_arg" ]; then echo "错误: 源 '$source_arg' 不存在。"; return 1; fi
  if [ ! -d "$dest_dir_arg" ]; then echo "错误: 目标 '$dest_dir_arg' 不是一个目录。"; return 1; fi

  # 计算最终的目标路径
  local source_basename=$(basename "$source_arg")
  local final_dest_path="$(realpath "$dest_dir_arg")/$source_basename"
  
  if [ -e "$final_dest_path" ]; then echo "错误: 目标位置 '$final_dest_path' 已存在。"; return 1; fi

  echo "准备执行正向操作..."
  echo "步骤 1: 移动 '$source_arg' -> '$final_dest_path'..."
  # 直接使用用户提供的源路径，mv 可以正确处理
  mv "$source_arg" "$final_dest_path" && \
  echo "步骤 2: 创建链接 '$source_arg' -> '$final_dest_path'..." && \
  # 在用户提供的原始位置创建链接，指向新的绝对路径
  ln -s "$final_dest_path" "$source_arg" && \
  echo "✅ 操作成功！"
}

```


然后跑到你的微信文件夹下：

```shell
cd  ~/Library/Containers
mvln com.tencent.xinWeChat /Volumes/T7-red
```

效果：

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/659707b55f503dfeb3122949b179caeb.png?x-oss-process=image/quality,q_90/rotate,0)

最后效果：

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/c8c635c0a9d27db1b18d39d8f1f99b01.png?x-oss-process=image/quality,q_90/rotate,0)

我们的 `mvln` 还可以撤销：

```shell
mvln -r com.tencent.xinWeChat
```


![](https://poketto.oss-cn-hangzhou.aliyuncs.com/0b8c373d6b3dd788d175589f9db59741.png?x-oss-process=image/quality,q_90/rotate,0)


最后重新为微信签名即可：

```shell
sudo codesign --sign - --force --deep /Applications/WeChat.app
```

加油，期待听到你的好消息~