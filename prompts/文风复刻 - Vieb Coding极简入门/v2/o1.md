---
title: "Vibe Coding 革命：从“氛围组”到“实战派”，重塑你的开发工作流"
subtitle: "一篇写给新人和朋友的极简入门教程，帮你丝滑地进入 AI Native 开发新范式"
date: 2025-11-05
---

> 当开发的“氛围感”可以直接转化为生产力，我们离想象中的未来又近了一步。这篇文章不仅是一份内部培训讲义，也是我为你准备的一张进入 Vibe Coding 新世界的门票。

### ### Key Insights

*   **Vibe 优先，Code 随行**：对于绝大多数非专业开发者，AI 工具链的成熟，意味着你可以完全聚焦于“想要什么”，而非“如何实现”。通过 Vibe 驱动创造，AI 负责繁琐的编码。
*   **命令行：专业开发者的浪漫与基石**：尽管 GUI 工具日益强大，但命令行（CLI）依旧是专业开发者追求极致效率、沉浸感与掌控力的核心阵地。AI Native 时代的 CLI，更是如虎添翼。
*   **磨刀不误砍柴工**：一个精心配置的本地开发环境，是高效 Vibe Coding 的放大器。从网络到终端，从包管理到 AI 助手，每一个环节的优化，都将在后续开发中为你节省大量时间。
*   **上下文是 AI 的灵魂**：无论工具如何演进，让 AI 精准理解你的意图和项目上下文，始终是释放其潜能的关键。未来的竞争，是“提供高质量上下文”能力的竞争。

## 一、风起于青萍之末：我们为什么聊 Vibe Coding？

最近团队来了几位新同事，同时身边也有不少朋友向我咨询如何入门 AI 编程。我发现一个有趣的现象：无论是经验丰富的开发者，还是对代码一窍不通的产品经理，大家都被一种新的开发范式所吸引——我称之为 **Vibe Coding**。

<!-- 评注建议：这里可以分享一个你个人或团队，在实际项目中被 Vibe Coding 的高效率或创造力所震撼的具体小故事，增加文章的代入感和说服力。 -->

所谓 Vibe Coding，核心在于“Vibe”——氛围、感觉、想法。你不再需要逐行逐句地跟机器用严谨的代码逻辑对话，而是可以用自然语言、草图，甚至一张参考图片，来描述你脑海中的产品形态和感觉。AI 则像一个心有灵犀的超级程序员，将你的“Vibe”翻译成高质量、可执行的代码。

这个趋势无疑是令人兴奋的。它极大地降低了创造的技术门槛，让不懂代码的人也能快速将想法变为现实；对于专业开发者而言，它则将我们从大量重复、繁琐的“胶水代码”和“模板代码”中解放出来，得以更专注于业务逻辑和系统架构的创新。

这股风潮已经很盛，并且我们坚信它就是未来。因此，为新同事做一次系统性的培训，并将其整理成文，分享给更多走在时代前沿的朋友，便成了这篇万字长文的由来。它既是一份内部培训讲义，也是一张通往 AI Native 开发新世界的邀请函。

## 二、只爱 Vibe，不爱 Code？普通人的极速“创世”体验

在正式进入专业开发者的“硬核”部分之前，我们先为那些只想快速验证想法、对底层代码不感兴趣的朋友，指几条捷径。毕竟，Vibe Coding 的一大魅力，就是让“想法”本身成为主角。

如果你只是想快速生成一个网页应用，体验一下“说到做到”的快感，市面上有许多优秀的可视化工具能满足你。

### 快速生成一个网页App

*   **[Lovable](https://lovable.dev/)**：这是一款出色的 AI 网站构建工具。你只需要通过对话描述你的业务、目标用户和网站风格，Lovable 就能在几分钟内为你生成一个设计精良、功能完备的网站。 整个过程就像和一位产品经理加设计师沟通，非常直观。
*   **Figma + AI 插件**：如果你本身就是设计师，或者习惯用 Figma 表达想法，那么现在大量的 AI 插件（如 [Anima](https://www.animaapp.com/), [Builder.io](https://www.builder.io/) 等）可以直接将你的设计稿一键转换为 React、Vue、HTML 等前端代码。 虽然代码质量可能需要后期优化，但作为原型验证，效率极高。
*   **网页版 Claude Code / Codex**：这些大型语言模型的网页聊天界面，本身就是强大的代码生成器。你可以直接在对话框里说：“帮我写一个待办事项应用的React组件”，它会立刻给你提供完整的代码片段，你甚至可以要求它使用特定的技术栈或UI库。

### 复刻一个别人的网页

有时候，最好的灵感来源就是模仿。当你看到一个心仪的网站，想快速拥有一个类似的作为起点时，以下工具能帮你实现：

*   **[same.new](https://same.new/)**：这个工具堪称“像素级”网站克隆神器。 你只需输入一个网址，它就能通过 AI 分析该网站的结构、组件、样式甚至交互逻辑，然后生成一套可维护的、基于现代前端框架（如 Next.js 和 Tailwind CSS）的代码。 这对于学习优秀网站的设计和实现，或者快速搭建项目骨架来说，极其有用。
*   **Heyboss.ai**：与 same.new 类似，Heyboss 也提供了强大的网站复刻能力，帮助你快速从一个现有的 URL 创建一个新项目。

通过这些工具，非专业开发者可以在不接触一行代码的情况下，初步建立起对“想法”到“产品”的具像化感知。这不仅有趣，也为你后续与开发者协作，或者自己深入学习，打下了坚实的基础。

## 三、磨刀不误砍柴工：专业开发者的命令行“仙境”

好了，欢迎来到本文的核心章节。

对于我们专业开发者而言，虽然上述可视化工具很方便，但它们往往也意味着更少的控制权、更低的灵活性以及对特定平台的依赖。想要真正解锁 Vibe Coding 的全部潜力，获得更专业、更沉浸式的开发体验，我们依然要回到最熟悉也最强大的阵地——**命令行（Command Line Interface, CLI）**。

<!-- 评注建议：可以强调一下命令行工作流的“心流”体验。在 CLI 中，双手不离开键盘，通过高效的指令和 AI 协作，能达到一种行云流水、人机合一的沉浸状态，这是 GUI 难以比拟的。 -->

AI Native 时代的命令行，不再是冷冰冰的字符界面，而是我们与 AI 助手高效协作的“驾驶舱”。在这里，我们可以用最精炼的指令，调用最强大的 AI 能力，完成从环境配置、代码生成、重构到测试部署的全链路工作。

正所谓“磨刀不误砍柴工”，在起飞之前，我们需要精心打造我们的“机甲”——一个配置完善、得心应手的本地开发环境。由于我日常使用 Mac，下面的教程将以 macOS 为例。

### 1. 突破次元壁：网络代理配置

对于身处大陆的开发者来说，这是我们通往世界级 AI 服务的第一步，也是最关键的一步。由于 Anthropic (Claude) 和 OpenAI (Codex/ChatGPT) 的服务节点均在海外，一个稳定、高效的网络代理是必不可少的。

这里我们不推荐具体的代理服务商，但主流的实现方式通常是使用 [ClashX](https://github.com/yichengchen/clashX) 等客户端软件。配置好客户端后，最重要的一步是在你的 Shell 环境中设置代理，这样命令行工具才能通过代理访问网络。

打开你的 Shell 配置文件（通常是 `~/.zshrc` 或 `~/.bash_profile`），在文件末尾添加以下内容：

```bash
# proxy
export ALL_PROXY="http://127.0.0.1:7890"
export HTTP_PROXY="http://127.0.0.1:7890"
export HTTPS_PROXY="http://127.0.0.1:7890"
```

> **注意**：`7890` 是 ClashX 等工具默认的本地 HTTP/HTTPS 代理端口，请根据你的客户端实际设置进行修改。

添加完毕后，执行 `source ~/.zshrc` (或对应的配置文件) 使其生效。你可以通过 `curl www.google.com` 命令来测试代理是否配置成功。

### 2. 终端进化：iTerm2 + zsh + oh-my-zsh

macOS 自带的 Terminal.app 功能有限，`iTerm2` 是公认的更佳替代品，它提供了分屏、自定义主题、触发器等大量高级功能。 而 `zsh` 作为 macOS 的默认 Shell，搭配上 `oh-my-zsh` 这个终极配置框架，能让你的终端体验产生质的飞跃。

```ad-tip Zsh & Oh My Zsh

**Zsh (Z Shell)** 是一种功能强大的 Shell（命令行解释器），作为 macOS 的默认 Shell，它兼容 Bash 并提供了更多高级功能，如更智能的自动补全、拼写纠错、可定制的主题和插件系统。

**Oh My Zsh** 是一个开源的、社区驱动的 Zsh 配置管理框架。 它极大地简化了 Zsh 的配置过程，内置了数百个强大的插件（针对 git、docker、python 等）和丰富的主题，让你无需手动配置就能拥有一个美观且功能强大的终端。
```

**安装步骤**：

1.  **安装 Homebrew** (如果你还没有)：Homebrew 是 macOS 的包管理器，是后续安装所有工具的基础。
    ```bash
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ```

2.  **安装 iTerm2**：
    ```bash
    brew install --cask iterm2
    ```
    安装后，你就可以在“应用程序”文件夹中找到并使用 iTerm2 了。后续所有操作，我们都将在 iTerm2 中进行。

3.  **安装 Oh My Zsh**：
    ```bash
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
    ```
    安装过程中，它会自动备份你现有的 `~/.zshrc` 文件，并创建一个新的配置文件。

安装完成后，你的终端提示符会立刻变得不一样。你可以通过编辑 `~/.zshrc` 文件来更换主题（`ZSH_THEME` 变量）和启用插件（`plugins` 数组）。我个人推荐 `agnoster` 主题和 `zsh-autosuggestions`、`zsh-syntax-highlighting` 等实用插件。

### 3. 工作区魔法：tmux + oh-my-tmux

`tmux` 是一个终端复用器 (Terminal Multiplexer)，它是命令行工作流中的“神器”，尤其适合需要同时处理多个任务、管理远程服务器会话的场景。

```ad-tip tmux：终端中的“窗口管理器”

想象一下，你正在本地终端通过 SSH 连接一台远程服务器编译代码，这时网络突然断开，你的编译任务也就中断了。`tmux` 就是为了解决这类问题而生的。

它的核心功能包括：
1.  **会话保持 (Sessions)**：在 `tmux` 中启动的任务，即使你关闭了终端窗口或断开连接，它们也会在后台继续运行。你可以随时重新连接（attach）到之前的会话，恢复工作现场。
2.  **窗口和窗格 (Windows & Panes)**：一个 `tmux` 会话可以包含多个窗口（类似浏览器标签页），每个窗口又可以分割成多个窗格（类似 iTerm2 的分屏），让你在一个界面内轻松管理多个命令行任务。
3.  **结对编程**：多名用户可以同时连接到同一个 `tmux` 会话，实现命令行的实时协作。```

虽然 `tmux` 功能强大，但其默认配置和快捷键对新手并不友好。`oh-my-tmux` 则是一个开箱即用的 `tmux` 配置文件，它提供了更美观的界面和更符合直觉的快捷键。

**安装步骤**：

1.  **安装 tmux**：
    ```bash
    brew install tmux
    ```

2.  **安装 oh-my-tmux**：
    ```bash
    cd
    git clone https://github.com/gpakosz/.tmux.git
    ln -s -f .tmux/.tmux.conf
    cp .tmux/.tmux.conf.local .
    ```

现在，在终端输入 `tmux` 即可启动一个全新的、经过美化的 `tmux` 会话。你可以尝试使用快捷键：
*   `Ctrl + b` 然后按 `%`：垂直分割窗格。
*   `Ctrl + b` 然后按 `"`：水平分割窗格。
*   `Ctrl + b` 然后按 `方向键`：在窗格间切换。
*   `Ctrl + b` 然后按 `d`：暂时分离（detach）当前会话。
*   `tmux a`：重新连接（attach）到上一个会话。

掌握 `tmux` 将极大地提升你在命令行中的多任务处理能力。

### 4. 必备三件套：Git + Node.js (nvm) + pnpm

这三者是现代前端开发的基石。

*   **Git**：版本控制系统，无需多言。macOS 通常自带，你可以通过 `git --version` 检查。
*   **Node.js**：JavaScript 运行环境。由于不同项目可能依赖不同版本的 Node.js，强烈建议使用 `nvm` (Node Version Manager) 来管理。
*   **pnpm**：一个更快、更节省磁盘空间的包管理器。

```ad-tip npm vs pnpm：为什么我们选择 pnpm？

`npm` 是 Node.js 官方的包管理器，但它的 `node_modules` 设计存在一些问题：
1.  **磁盘空间占用**：不同的项目，即使依赖了相同的包，`npm` 也会在每个项目的 `node_modules` 目录下完整地复制一份，造成大量磁盘空间浪费。
2.  **“幻影依赖”**：`npm` v3+ 采用扁平化的 `node_modules` 结构，这导致你的代码可以访问到那些“依赖的依赖”，即没有在 `package.json` 中明确声明的包。这可能引发潜在的版本冲突和维护问题。

**`pnpm` 通过巧妙的机制解决了这些问题**：
1.  **内容寻址存储**：`pnpm` 会在全局（`~/.pnpm-store`）维护一个内容寻址的存储库。安装包时，它会将包文件硬链接到这个全局仓库，而不是复制。 这意味着，任何包的任何版本，在你的磁盘上都只存一份，极大节省了空间。
2.  **严格的 `node_modules` 结构**：`pnpm` 创建了一个非扁平的 `node_modules` 目录，通过符号链接（symlinks）来组织依赖关系。这确保了你的代码只能访问到 `package.json` 中明确声明的直接依赖，避免了“幻影依赖”问题，增强了项目的健壮性。
```

**安装步骤**：

1.  **安装 nvm**：
    ```bash
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    ```
    安装后，根据提示将 `nvm` 的初始化脚本添加到你的 `~/.zshrc` 文件中，并 `source ~/.zshrc` 重启终端。

2.  **使用 nvm 安装 Node.js**：
    ```bash
    nvm install --lts # 安装最新的长期支持（LTS）版本
    nvm use --lts     # 使用该版本
    nvm alias default 'lts/*' # 设置为默认版本
    ```

3.  **安装 pnpm**：
    ```bash
    npm install -g pnpm
    ```

### 5. 注入灵魂：AI 编码助手 (Claude Code & Codex)

终于到了最激动人心的部分——为我们的命令行“机甲”安装 AI 引擎。我们将主要配置 Anthropic 的 `Claude Code` 和 OpenAI 的 `Codex`。

#### Claude Code (CLI)

`Claude Code` 是 Anthropic 官方推出的命令行 AI 助手。 它可以理解你的整个项目上下文，帮你编写代码、修复 Bug、生成测试、解释代码逻辑，甚至执行终端命令。

**安装与配置**：

1.  **全局安装**：
    ```bash
    npm install -g @anthropic-ai/claude-code
    ```
    **注意**：安装和后续登录过程，需要确保你的网络代理已开启，并且 **登录时需要使用美国节点**，否则可能无法通过认证。

2.  **登录授权**：
    在你的项目根目录下，首次运行 `claude` 命令：
    ```bash
    claude
    ```
    它会引导你通过浏览器登录 Anthropic 账户并进行授权。 成功后，API 密钥会自动存储在本地。你需要拥有一个付费的 Claude Pro 或 Max 订阅才能使用。

#### Codex (OpenAI API)

虽然 `Codex` 这个名字最初指代 OpenAI 的一个特定模型，现在它更泛指通过 OpenAI API 实现的编码能力。为了在命令行中使用它，我们主要是配置好 OpenAI 的 API 密钥。

**配置步骤**：

1.  **获取 API Key**：访问 [OpenAI Platform](https://platform.openai.com/api-keys) 创建一个新的 API 密钥。
2.  **设置为环境变量**：将密钥配置为环境变量，这是最安全、最通用的做法。编辑 `~/.zshrc` 文件，添加：
    ```bash
    export OPENAI_API_KEY="sk-YourOpenAISecretKey"
    ```
    将 `sk-YourOpenAISecretKey` 替换为你自己的密钥。然后 `source ~/.zshrc` 使其生效。

有了这个环境变量，任何支持 OpenAI API 的命令行工具（包括后面我们可能会用到的自定义脚本），都可以直接调用 GPT-4o 等强大的模型能力。

此外，OpenAI 也提供了一个名为 `@openai/codex` 的官方实验性 CLI 工具，安装方式类似 Claude Code：`npm install -g @openai/codex`。 你也可以安装它作为补充。

### 6. 完美搭档：VSCode

尽管我们的核心工作流在命令行，但一个强大的代码编辑器仍然是不可或缺的。VSCode 凭借其卓越的性能、丰富的扩展生态和与终端的无缝集成，成为我们的不二之选。

**建议安装的 VSCode 扩展**：
*   **iTerm2 Theme**：让 VSCode 的集成终端与你的 iTerm2 保持风格统一。
*   **GitLens**：极大地增强了 VSCode 的 Git 功能，能让你清晰地看到每一行代码的修改历史。
*   **ESLint / Prettier**：保证代码风格和质量的利器。
*   **Claude Code Extension**：安装 Claude Code CLI 后，它可以提示你在 VSCode 中安装官方扩展，将 AI Agent 的能力无缝集成到 IDE 中。

到此为止，我们已经拥有了一套武装到牙齿的、基于命令行的专业 Vibe Coding 开发环境。后续的文章，我们还会详细介绍和对比 `Cursor` 这样的 AI Native 编辑器，以及网页版 Claude Code 等不同形态的产品，但今天这套 CLI 工作流，是你探索一切可能性的坚实起点。

<!-- 评注建议：这里可以总结一下这套环境的核心优势：高度可定制、不受平台锁定、极致的键盘驱动效率，以及与 Git 等原生开发者工具的深度集成。这是一种属于“高手”的浪漫。 -->

## 四、小试牛刀：用 Vibe 生成一个 React Demo

理论说了一大堆，环境也配好了，是时候来一次实战演练，感受一下这套工作流的威力了。我们将快速创建一个 React 应用，并用 AI 来帮我们编写一个核心组件。

### 1. 初始化项目

我们使用 `Vite` 这个现代化的前端构建工具来快速搭建项目骨架。它以其极快的冷启动速度和热更新性能而闻名。

打开你的 iTerm2，进入你存放项目的目录，然后执行：

```bash
pnpm create vite@latest my-react-demo --template react-ts
```

这个命令会创建一个名为 `my-react-demo` 的新目录，并使用基于 TypeScript 的 React 模板进行初始化。

接下来，进入项目目录并安装依赖：

```bash
cd my-react-demo
pnpm install
```

最后，启动开发服务器：

```bash
pnpm run dev
```

现在，在浏览器中打开提示的地址（通常是 `http://localhost:5173`），你应该能看到 Vite 和 React 的欢迎页面了。

### 2. 与 AI 对话，生成组件

假设我们想创建一个简单的“随机笑话生成器”组件。它需要一个按钮，每次点击时从一个 API 获取一条笑话并显示出来。

在项目根目录下，启动 Claude Code：

```bash
claude
```

进入 Claude 的交互界面后，我们用自然语言向它下达指令。注意，一个好的 Prompt 是 Vibe Coding 的关键。

> Help me create a new React component named `JokeGenerator.tsx` inside the `src/components` directory. This component should fetch a random joke from the `https://official-joke-api.appspot.com/random_joke` API when a button is clicked. It should display the joke's "setup" and "punchline" in a visually appealing way. Please use `useState` and `useEffect` hooks, and handle loading and error states. Also, please use TypeScript.
>
> *完整prompt见：https://thepromptbase.com/p/react-joke-generator-component-prompt*

Claude Code 会分析你的请求，理解你的意图（创建文件、编写组件、API交互、状态管理等），然后它会向你确认将要执行的操作，例如：

```
Okay, I will perform the following actions:
1. Create a new directory `src/components`.
2. Create a new file `src/components/JokeGenerator.tsx`.
3. Write the React component code with the specified logic into the new file.
4. Modify `src/App.tsx` to import and render the new `JokeGenerator` component.

Do you approve? (y/n)
```

输入 `y` 并回车。几秒钟后，Claude 就会完成所有操作。你甚至不需要离开终端，就能完成组件的创建、编码和集成。

现在，回到浏览器查看你的应用，你会发现一个新的组件已经出现了。点击按钮，它就能正常工作了。

### 3. 未来展望与我们的“秘密武器”

通过刚才的 Demo，你应该已经感受到了这套 CLI 工作流的丝滑之处。

当然，这只是一个开始。在后续的文章中，我们会继续深入，带大家一起使用 `Next.js` (业界领先的 React 框架), `shadcn/ui` (一个优雅的组件库), `Supabase` (开源的 Firebase 替代品，提供数据库和后端服务) 以及 `Vercel` (全球领先的前端部署平台)，一步步搭建一个真正可以商业化的 2C 产品。

在那个过程中，我们也会揭晓团队内部正在孵化的一个“秘密武器”——一个基于我们二次开发的社区插件 `code-inspector`。

我们发现，尽管命令行开发模式极其高效，但它在“上下文获取”方面存在天然的短板。当你面对一个复杂的项目，想让 AI 帮你修改某个深埋在代码库里的函数时，单靠对话很难精准地把这个函数的完整上下文（例如，它的定义、被谁调用、依赖哪些外部模块等）传递给 AI。

而 `code-inspector` 插件正是为了解决这个痛点。它能够与你的编辑器（如 VSCode）深度集成，让你通过简单的可视化操作，就能精准地“框选”出你需要的代码片段及其所有相关的依赖，将其打包成一个完美的、富含上下文的 Prompt，一键发送给 Claude Code 或其他 AI 助手。

这，才是命令行开发模式与 AI 协作的完全体。它既保留了 CLI 的高效与沉浸，又弥补了其在视觉化上下文感知上的不足。

敬请期待。在那之前，先享受配置和把玩你全新的开发环境吧！