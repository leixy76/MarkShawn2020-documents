---
title: "深度编译：Claude Code凭什么这么好用？"
subtitle: "通过逆向工程日志，我们得以一窥其返璞归真的Agent设计哲学"
date: 2025-08-24
author: "手工川 编译"
source_url: "https://minusx.ai/blog/decoding-claude-code/"
---

### 引言 (Intro)

就在三天前（2025年8月21日），MinusX 博客发布了一篇极为精彩的逆向工程分析文章，深入探讨了 Anthropic 官方出品的 CLI 工具 Claude Code 为何能提供如此“令人愉悦”的开发体验。作者 Vivek 通过拦截和分析数月的使用日志，为我们揭示了 Claude Code 背后简单而强大的设计哲学。

本文并非对 Claude Code 架构的完整复现，而是基于原文的核心洞察，为所有致力于构建优秀 LLM Agent 的开发者提供一份参考指南。文章的核心论点可以概括为一句话：**Claude Code 的成功，源于其在每个技术抉择点上对“架构简洁性”的极致追求，它深刻理解了 LLM 的长处与短板，并通过精巧的提示工程与工具设计，让模型在其“舒适区”内大放异彩。**

接下来，我们将深入编译这篇文章的核心内容，并为你揭示那些可被复刻到你自己 Agent 中的“魔法”。

### 核心发现摘要 (TL;DR)

如果你只想带走一件事，那就是——**保持简单，伙计 (Keep Things Simple, Dummy)**。LLM 的调试与评估已足够困难，任何你引入的额外复杂性（如多智能体、代理切换、复杂的 RAG 算法）只会让调试难度指数级上升。

以下是从 Claude Code 中提炼出的关键实践，可以直接应用到你的系统中：

1.  **控制循环 (Control Loop)**
    *   **1.1 坚持单一主循环**：保持一个主循环（最多一个分支）和一份消息历史记录，这能极大地提升系统的可调试性。
    *   **1.2 善用小模型**：在各种辅助任务中（如读取大文件、解析网页、总结历史记录）高频使用更小、更便宜的模型。

2.  **提示词 (Prompts)**
    *   **2.1 使用 `claude.md` 模式**：通过一个专门的配置文件与用户协作，沉淀上下文和偏好设置。
    *   **2.2 善用特殊 XML 标签和 Markdown**：利用 `<good-example>`, `<bad-example>` 等标签和 Markdown 标题来结构化提示，提供清晰的启发式规则和示例。

3.  **工具 (Tools)**
    *   **3.1 LLM 原生搜索 > RAG**：让 LLM 直接调用 `ripgrep`, `jq`, `find` 等原生命令行工具进行代码搜索，而不是引入复杂的 RAG 系统。
    *   **3.2 精心设计工具层级**：混合使用低阶（如 Bash）、中阶（如 Edit, Grep）和高阶（如 WebFetch）工具，在灵活性和确定性之间取得平衡。
    *   **3.3 让 Agent 管理自己的待办事项**：通过一个由 Agent 自身维护的 `ToDo` 列表来防止“上下文遗忘”，并保持任务焦点。

4.  **可控性 (Steerability)**
    *   **4.1 定义基调与风格**：在系统提示中明确规定 Agent 的沟通风格，使其交互“有品位”。
    *   **4.2 “PLEASE THIS IS IMPORTANT” 仍然是 SOTA**：不幸的是，使用大写、强调词汇仍然是引导模型行为最有效的方式之一。
    *   **4.3 明确写下算法**：对于核心任务，以流程图的形式明确写下决策路径、启发式规则和示例，而不是提供一堆混乱的“Dos”和“Don'ts”。

> **手工川评注建议**：
> 这里的核心思想——“架构简洁性战胜一切”，几乎是对当前 AI Agent 领域普遍存在的“过度工程化”趋势的一剂解药。许多开发者痴迷于构建复杂的 Multi-Agent、CoT、ReAct 框架，却忽略了最根本的问题：系统的可调试性和可预测性。Claude Code 的实践仿佛在提醒我们，“苦涩的教训”再次上演——与其构建复杂的脚手架，不如打造一个好的“缰绳”，然后让模型自己去“烹饪”。这与自动驾驶领域“端到端 vs. 模块化”的路线之争何其相似。

---

### 1. 控制循环设计 (Control Loop Design)

#### 1.1 坚持单一主循环 (Keep One Main Loop)

**可调试性远胜于复杂的、精调的多智能体 LangChain-Graph-Node 混合体。**

尽管多智能体系统风靡一时，Claude Code 却只有一个主线程。它会周期性地使用一些不同类型的提示来总结 git 历史、压缩消息历史或创造一些有趣的 UX 元素。但除此之外，它维护的是一个扁平的消息列表。

一个有趣的设计是，当它处理层级任务时，它会**生成一个自身的克隆作为子代理**，但这个子代理不具备再次生成子代理的能力。这意味着任务树最多只有一个分支，其结果最终会作为一个“工具响应”被添加回主消息历史中。这种“最大单分支”策略与 ToDo 列表相结合，确保了 Agent 既能分解问题，又能时刻关注最终目标。

![Control Loop](https://minusx.ai/images/claude-code/control_loop.gif)

#### 1.2 善用小模型 (Use a Smaller model for *everything*)

Claude Code 中超过50%的重要 LLM 调用都指向了 `claude-3-5-haiku`。它被用来读取大文件、解析网页、处理 git 历史和总结长对话。甚至，用户输入的每一个按键触发的“正在处理”标签，都是由小模型生成的。这些小模型比标准模型（如 Sonnet 4, GPT-4.1）便宜70-80%。请尽情地使用它们！

---

### 2. 提示词 (Prompts)

Claude Code 的提示词极为详尽，充满了启发式规则、示例和 `IMPORTANT` 提醒。其系统提示词长达约2800个 token，工具定义更是高达9400个 token。

#### 2.1 使用 `claude.md` 协作管理上下文

许多编码 Agent 的创造者都殊途同归地采用了“上下文文件”这一模式（例如 Cursor Rules / claude.md / agent.md）。有没有 `claude.md`，Claude Code 的表现判若两人。这是一个绝佳的方式，让开发者能够传递那些无法从代码库中推断出的上下文，并固化一些严格的偏好。例如，你可以强制 LLM 跳过某些文件夹，或使用特定的库。CC 在每个用户请求中都会发送 `claude.md` 的全部内容。

#### 2.2 特殊XML标签、Markdown和大量示例

XML 标签和 Markdown 是结构化提示词的两种公认有效方法。CC 广泛地同时使用了两者。

*   **`<system-reminder>`**: 在许多提示部分的末尾用来提醒 LLM 那些它“可能”会忘记的事情。
*   **`<good-example>`, `<bad-example>`**: 用于固化启发式规则。当模型面临多个看似合理的路径选择时，这些标签通过对比案例，清晰地指明了哪条路是更优的。
*   **Markdown 标题**: CC 还使用 Markdown 标题来划分系统提示中的不同区域，如“基调与风格”、“主动性”、“遵循惯例”等。

---

### 3. 工具 (Tools)

#### 3.1 LLM 原生搜索 >>> RAG 搜索

CC 与其他流行编码 Agent 的一个显著区别在于它**拒绝了 RAG**。Claude Code 搜索代码库的方式和你我一样，通过执行非常复杂的 `ripgrep`、`jq` 和 `find` 命令。由于 LLM 对代码有深刻的理解，它能使用复杂的正则表达式找到任何它认为相关的代码块。

> **手工川评注建议**：
> 作者将“LLM 原生搜索 vs. RAG”比作“摄像头 vs. 激光雷达 (Lidar)”，这是一个非常精妙的类比。RAG 理论上很美好，但它引入了新的、且更隐蔽的故障点：相似度函数如何选择？如何重排？代码如何分块？而 LLM 原生搜索将这些复杂性交还给了模型本身，这不仅减少了系统的“活动部件”，更重要的是，这种行为是可以通过强化学习进行优化的。这是否预示着 Agent 工具使用的一个重要发展方向？

#### 3.2 如何设计好工具？(高阶 vs. 低阶)

应该给模型提供泛化的动作（高阶），还是底层的操作（如键鼠、Bash）？答案是：**两者都要**。

Claude Code 拥有低阶（Bash, Read, Write）、中阶（Edit, Grep, Glob）和高阶（Task, WebFetch）工具。既然有了 Bash，为什么还要单独提供 Grep 工具？这里的权衡在于 **Agent 使用该工具的频率 vs. Agent 使用该工具的准确性**。Grep 和 Glob 的使用频率如此之高，以至于将它们独立为工具是值得的，同时保留通用的 Bash 命令以应对特殊场景。

#### 3.3 让 Agent 管理自己的待办事项列表

“上下文遗忘”是长时运行 LLM Agent 的常见病。许多 Agent 尝试通过显式 ToDo 列表（一个模型生成 ToDo，另一个模型执行）或多智能体接力+验证来解决。

CC 使用的是一个**由模型自身维护的显式 ToDo 列表**。这让 LLM 始终保持在正轨上（提示词中被反复强调要查阅 ToDo 列表），同时又给予了模型在执行中途修正路线的灵活性。这也有效地利用了模型的“交错思考”（interleaved thinking）能力，可以动态地拒绝或插入新的 ToDo 项。

---

### 4. 可控性 (Steerability)

#### 4.1 定义基调与风格

CC 在系统提示中明确地定义了 Agent 的审美行为，包括“基调”、“风格”和“主动性”等章节，并附有大量指令和示例。这就是为什么 Claude Code 在注释和响应积极性上显得“有品位”。

#### 4.2 "THIS IS IMPORTANT" 仍然是 SOTA

不幸的是，在要求模型“不要做某事”方面，CC 也没什么新花样。`IMPORTANT`, `VERY IMPORTANT`, `NEVER`, `ALWAYS` 似乎仍然是引导模型避开雷区的最佳方式。

#### 4.3 明确写下算法 (附带启发式规则和示例)

至关重要的一点是，识别出 LLM 需要执行的最重要的任务，并为其**写出算法**。尝试以流程图的形式，明确地写下所有决策点。这比提供一堆杂乱的、甚至可能相互冲突的“Dos and Don'ts”要有效得多。在 Claude Code 的系统提示中，`Task Management`, `Doing Tasks` 和 `Tool Usage Policy` 等部分就清晰地描述了需要遵循的算法。

### 结论 (Conclusion)

再次强调，核心要义是**保持简单**。过度的脚手架框架弊大于利。Claude Code 的实践证明，一个“Agent”可以既简单又极其强大。对于所有 Agent 开发者而言，这不仅是一次技术上的揭秘，更是一次关于设计哲学的深刻启示。

---

### 附录 (Appendix)

原文作者提供了 Claude Code 的系统提示词和工具定义全文，这里将其收录以供参考。

<details>
<summary><strong>点击展开：主要系统提示词 (Main System Prompt)</strong></summary>